primitive TestData
    fun message1() : String =>
        """
Content-Length: 2976

"""

    fun message2(): String =>
        """
{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":20308,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"d:\\Coding\\Pony\\http_server","rootUri":"file:///d%3A/Coding/Pony/http_server","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/Coding/Pony/http_server","name":"http_server"}]}}"""

    fun message3() : String =>
        """
Content-Length: 52

"""

    fun message4() : String =>
        """
{"jsonrpc":"2.0","method":"initialized","params":{}}"""

    fun message5() : String =>
        """
Content-Length: 95

{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"pony":{}}}}Content-Length: 7437

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Coding/Pony/http_server/http_server/handler.pony","languageId":"pony","version":1,"text":"interface Handler\n  \"\"\"\n  This is the interface through which HTTP requests are delivered *to*\n  application code and through which HTTP 
responses are sent to the underlying connection.\n\n  Instances of a Handler are executed in the context of the `Session` actor so most of them should be\n  passing data on to a processing actor.\n\n  Each `Session` must have a unique instance of the handler. The\n  application code does not necessarily know when an `Session` 
is created,\n  so the application must provide an instance of `HandlerFactory` that\n  will be called at the appropriate time.\n\n  ### Receiving Requests\n\n  When an [Request](http-Request.md) is received on an [Session](http-Session.md) actor,\n  the corresponding [Handler.apply](http-Handler.md#apply) method is called\n  with the request and a [RequestID](http-RequestID). The [Request](http-Request.md)\n  contains the information extracted from HTTP Headers and the Request Line, but 
it does not\n  contain any body data. It is sent to [Handler.apply](http-Handler.md#apply) before the body\n  is fully received.\n\n  If the request has a body, its raw data is sent to the [Handler.chunk](http-Handler.md#chunk) method\n  together with the [RequestID](http-RequestID.md) of the request it belongs to.\n\n  Once all body data is received, [Handler.finished](http-Handler.md#finished) is called with the\n  [RequestID](http-RequestID.md) of the request it belongs to. Now is the time to act on the full body data,\n  if it hasn't been processed yet.\n\n  The [RequestID](http-Requestid.md) must be kept around for sending the response for this request.\n  This way the session can ensure, all responses are sent in the same order as they have been received,\n  which is required for HTTP pipelining. This way processing responses can be passed to other actors and\n  processing can take arbitrary times. The [Session](http-Session.md) will take care of sending\n  the responses in the correct order.\n\n  It is guaranteed that the call sequence is always:\n\n  - exactly once:       `apply(request_n, requestid_n)`\n  - zero or more times: `chunk(data, requestid_n)`\n  - exactly once:       `finished(requestid_n)`\n\n  And so on for `requestid_(n + 1)`. Only after `finished` has been called for 
a\n  `RequestID`, the next request will be received by the Handler instance, there will\n  be no interleaving. So it is save to keep state for the given request in 
a Handler between calls to `apply`\n  and `finished`.\n\n  #### Failures and Cancelling\n\n  If a [Session](http-Session.md) experienced faulty requests, the [Handler](http-Handler.md)\n  is notified via [Handler.failed](http-Handler.md#failed).\n\n  If the underlying connection to a [Session](http-Session.md) has been closed,\n  the [Handler](http-Handler.md) is notified via [Handler.closed](http-Handler.md#closed).\n\n  ### Sending Responses\n\n  A handler is instantiated using a [HandlerFactory](http-HandlerFactory.md), which passes an instance of\n  [Session](http-Session.md) to be used in constructing a handler.\n\n  A Session is required to be able to send responses.\n  See the docs for [Session](http-Session.md) for ways to send responses.\n\n  Example Handler:\n\n  ```pony\n  use \"http\"\n  use \"valbytes\"\n\n  class MyHandler is Handler\n    let _session: Session\n\n    var _path: String = \"\"\n    var _body: ByteArrays = ByteArrays\n\n    new create(session: Session) =>\n      _session = session\n\n    fun ref apply(request: Request val, request_id: RequestID): Any =>\n      _path = request.uri().path\n\n    fun ref chunk(data: ByteSeq val, request_id: RequestID) =>\n      _body = _body + data\n\n    fun ref finished(request_id: RequestID) =>\n      _session.send_raw(\n        Responses.builder()\n          .set_status(StatusOk)\n          .add_header(\"Content-Length\", (_body.size() + _path.size() + 13).string())\n          .add_header(\"Content-Type\", \"text/plain\")\n          .finish_headers()\n          .add_chunk(\"received \")\n          .add_chunk((_body = ByteArrays).array())\n          .add_chunk(\" at \")\n          .add_chunk(_path)\n          .build(),\n        request_id\n      )\n      _session.send_finished(request_id)\n  ```\n\n  \"\"\"\n  fun ref apply(request: Request val, request_id: RequestID): Any =>\n    \"\"\"\n    Notification of an incoming message.\n\n    Only one HTTP message will be processed at a time, and that starts\n    with a call to this method.\n    \"\"\"\n\n  fun ref chunk(data: ByteSeq val, request_id: RequestID) =>\n    \"\"\"\n    Notification of incoming body data. The body belongs to the most\n    recent `Request` delivered by an `apply` notification.\n    \"\"\"\n\n  fun ref finished(request_id: RequestID) =>\n    \"\"\"\n    Notification that no more body chunks are coming. Delivery of this HTTP\n    message is complete.\n    \"\"\"\n\n  fun ref cancelled(request_id: RequestID) =>\n    \"\"\"\n    Notification that sending a response has been cancelled locally,\n    e.g. by closing the server or manually cancelling a single request.\n    \"\"\"\n\n  fun ref failed(reason: RequestParseError, request_id: RequestID) =>\n    \"\"\"\n    Notification about failure parsing HTTP requests.\n    \"\"\"\n\n  fun ref closed() =>\n    \"\"\"\n    Notification that the underlying connection has been closed.\n    \"\"\"\n\n  fun ref throttled() =>\n    \"\"\"\n    Notification that the session temporarily can not accept more data.\n    \"\"\"\n\n  fun ref unthrottled() =>\n    \"\"\"\n    Notification that the session can resume accepting data.\n    \"\"\"\n\n\ninterface HandlerFactory\n  \"\"\"\n  The TCP connections that underlie HTTP sessions get created within\n  the `http` package at times that the application code can not\n  predict. Yet, the application code has to provide custom hooks into\n  these connections as they are created. To accomplish this, the\n  application code provides an instance of a `class` that implements\n  this interface.\n\n  The `HandlerFactory.apply` method will be called when a new\n  `Session` is created, giving the application a chance to create\n  an instance of its own `Handler`. This happens on both\n  client and server ends.\n  \"\"\"\n\n  fun apply(session: Session): Handler ref^\n    \"\"\"\n    Called by the [Session](http-Session.md) when it needs a new instance of the\n    application's [Handler](http-Handler.md). It is suggested that the\n    `session` value be passed to the constructor for the new\n    [Handler](http-Handler.md), you will need it for sending stuff back.\n\n    This part must be implemented, as there might be more paramaters\n    that need to be passed for creating a Handler.\n   
 \"\"\"\n\ninterface HandlerWithoutContext is Handler\n  \"\"\"\n  Simple [Handler](http-Handler.md) that can be constructed\n  with only a Session.\n  \"\"\"\n  new create(session: Session)\n\n\nprimitive SimpleHandlerFactory[T: HandlerWithoutContext]\n  \"\"\"\n  HandlerFactory for a HandlerWithoutContext.\n\n  Just create it like:\n\n  ```pony\n  let server =\n    Server(\n      ...,\n      SimpleHandlerFactory[MySimpleHandler],\n      ...\n    )\n  ```\n\n  \"\"\"\n  fun apply(session: Session): Handler ref^ =>\n    T.create(session)\n"}}}"""

    fun message6() : String =>
        """
Content-Length: 58

"""

    fun message7() : String =>
        """
{"jsonrpc":"2.0","id":1,"method":"shutdown","params":null}"""

    fun largeMessagePart1() : String =>
        """
Content-Length: 17108

"""

    fun largeMessagePart2() : String =>
        """
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Coding/Pony/http_server/http_server/_test.pony","languageId":"pony","version":1,"text":"use \"ponytest\"\nuse \"ponycheck\"\nuse \"net\"\nuse \"collections\"\nuse \"itertools\"\nuse \"valbytes\"\nuse \"buffered\"\nuse \"time\"\n\nprimitive PrivateHTTPTests is TestList\n  fun tag tests(test: PonyTest) =>\n    test(_Encode)\n    test(_EncodeBad)\n    test(_EncodeIPv6)\n    test(_EncodeClean)\n\n    test(_Check)\n    test(_CheckBad)\n    test(_CheckScheme)\n    test(_CheckIPv6)\n\n    test(_Decode)\n    test(_DecodeBad)\n\n    test(_BuildBasic)\n    test(_BuildMissingParts)\n    test(_BuildBad)\n    test(_BuildNoEncoding)\n    test(_Valid)\n    test(_ToStringFun)\n    test(Property1UnitTest[Array[(RequestID, Array[U8] val)]](_PendingResponsesTest))\n\nclass iso _Encode is UnitTest\n  fun name(): String => \"http/URLEncode.encode\"\n\n  fun apply(h: TestHelper) ? =>\n    // Unreserved chars, decoded.\n    h.assert_eq[String](\"Aa4-._~Aa4-._~\",\n      URLEncode.encode(\"Aa4-._~%41%61%34%2D%2E%5F%7E\", URLPartUser)?)\n\n    h.assert_eq[String](\"F_12x\", URLEncode.encode(\"F_1%32x\", URLPartPassword)?)\n    h.assert_eq[String](\"F_12x\", URLEncode.encode(\"F_1%32x\", URLPartHost)?)\n    h.assert_eq[String](\"F_12x\", URLEncode.encode(\"F_1%32x\", URLPartPath)?)\n    h.assert_eq[String](\"F_12x\", URLEncode.encode(\"F_1%32x\", URLPartQuery)?)\n    h.assert_eq[String](\"F_12x\", URLEncode.encode(\"F_1%32x\", URLPartFragment)?)\n\n    // Sub-delimiters, left encoded or not as original.\n    h.assert_eq[String](\"!$&'()*+,;=%21%24%26%27%28%29%2A%2B%2C%3B%3D\",\n      URLEncode.encode(\"!$&'()*+,;=%21%24%26%27%28%29%2A%2B%2C%3B%3D\",\n        URLPartUser)?)\n\n    h.assert_eq[String](\",%2C\", URLEncode.encode(\",%2C\", URLPartPassword)?)\n    h.assert_eq[String](\",%2C\", URLEncode.encode(\",%2C\", URLPartHost)?)\n    h.assert_eq[String](\",%2C\", URLEncode.encode(\",%2C\", URLPartPath)?)\n    h.assert_eq[String](\",%2C\", URLEncode.encode(\",%2C\", URLPartQuery)?)\n    h.assert_eq[String](\",%2C\", URLEncode.encode(\",%2C\", URLPartFragment)?)\n\n    // Misc characters, encoded.\n    h.assert_eq[String](\"%23%3C%3E%5B%5D%7B%7D%7C%5E%20\" +\n      \"%23%3C%3E%5B%5D%7B%7D%7C%5E%25\",\n      URLEncode.encode(\"#<>[]{}|^ %23%3C%3E%5B%5D%7B%7D%7C%5E%25\",\n        
"""

    fun largeMessagePart3() : String =>
        """
       URLPartUser)?)\n\n    h.assert_eq[String](\"%23%23\", URLEncode.encode(\"#%23\", URLPartPassword)?)\n    h.assert_eq[String](\"%23%23\", URLEncode.encode(\"#%23\", URLPartHost)?)\n    h.assert_eq[String](\"%23%23\", URLEncode.encode(\"#%23\", URLPartPath)?)\n    h.assert_eq[String](\"%23%23\", URLEncode.encode(\"#%23\", URLPartQuery)?)\n    h.assert_eq[String](\"%23%23\", URLEncode.encode(\"#%23\", URLPartFragment)?)\n\n    // Delimiters, whether encoded depends on URL part.\n    h.assert_eq[String](\"%3A%40%2F%3F\", URLEncode.encode(\":@/?\", URLPartUser)?)\n    h.assert_eq[String](\":%40%2F%3F\",\n      URLEncode.encode(\":@/?\", URLPartPassword)?)\n    h.assert_eq[String](\"%3A%40%2F%3F\", URLEncode.encode(\":@/?\", URLPartHost)?)\n    h.assert_eq[String](\":@/%3F\", URLEncode.encode(\":@/?\", URLPartPath)?)\n    h.assert_eq[String](\":@/?\", URLEncode.encode(\":@/?\", URLPartQuery)?)\n    h.assert_eq[String](\":@/?\", URLEncode.encode(\":@/?\", URLPartFragment)?)\n\nclass iso _EncodeBad is UnitTest\n  fun name(): String => \"http/URLEncode.encode_bad\"\n\n  fun apply(h: TestHelper) =>\n    h.assert_error({() ? => URLEncode.encode(\"%2G\", URLPartUser)? })\n    h.assert_error({() ? => URLEncode.encode(\"%xx\", URLPartUser)? })\n    h.assert_error({() ? => URLEncode.encode(\"%2\", URLPartUser)? })\n\nclass iso _EncodeIPv6 is UnitTest\n  fun name(): String => \"http/URLEncode.encode_ipv6\"\n\n  fun apply(h: TestHelper) ? =>\n    // Allowed hex digits, '.' and ':' only, between '[' and ']'.\n    h.assert_eq[String](\"[1::A.B]\", URLEncode.encode(\"[1::A.B]\", URLPartHost)?)\n    h.assert_error({() ? => URLEncode.encode(\"[G]\", URLPartHost)? })\n    h.assert_error({() ? => URLEncode.encode(\"[/]\", URLPartHost)? })\n    h.assert_error({() ? => URLEncode.encode(\"[%32]\", URLPartHost)? })\n    h.assert_error({() ? => URLEncode.encode(\"[1]2\", URLPartHost)? })\n    h.assert_error({() ? => URLEncode.encode(\"[1\", URLPartHost)? })\n    h.assert_eq[String](\"1%5D\", URLEncode.encode(\"1]\", URLPartHost)?)\n\nclass iso _EncodeClean is UnitTest\n  fun name(): String => \"http/URLEncode.encode_clean\"\n\n  fun apply(h: TestHelper) ? =>\n    // No percent encoding in source string.\n    h.assert_eq[String](\"F_1x\", URLEncode.encode(\"F_1x\", URLPartQuery, false)?)\n    h.assert_eq[String](\"%2541\", URLEncode.encode(\"%41\", URLPartQuery, false)?)\n    h.assert_eq[String](\"%25\", URLEncode.encode(\"%\", URLPartQuery, false)?)\n\nclass iso _Check is UnitTest\n  fun name(): String => \"http/URLEncode.check\"\n\n  fun apply(h: TestHelper) =>\n    // Unreserved chars, legal encoded or not.\n    h.assert_eq[Bool](true,\n      URLEncode.check(\"Aa4-._~%41%61%34%2D%2E%5F%7E\", URLPartUser))\n\n    h.assert_eq[Bool](true, URLEncode.check(\"F_1%32x\", URLPartPassword))\n    h.assert_eq[Bool](true, URLEncode.check(\"F_1%32x\", URLPartHost))\n    h.assert_eq[Bool](true, URLEncode.check(\"F_1%32x\", URLPartPath))\n    h.assert_eq[Bool](true, URLEncode.check(\"F_1%32x\", URLPartQuery))\n    h.assert_eq[Bool](true, URLEncode.check(\"F_1%32x\", URLPartFragment))\n\n    // Sub-delimiters, legal encoded or not.\n    h.assert_eq[Bool](true,\n      URLEncode.check(\"!$&'()*+,;=%21%24%26%27%28%29%2A%2B%2C%3B%3D\",\n        URLPartUser))\n\n    h.assert_eq[Bool](true, URLEncode.check(\",%2C\", URLPartPassword))\n    h.assert_eq[Bool](true, URLEncode.check(\",%2C\", URLPartHost))\n    h.assert_eq[Bool](true, URLEncode.check(\",%2C\", URLPartPath))\n    h.assert_eq[Bool](true, URLEncode.check(\",%2C\", URLPartQuery))\n    h.assert_eq[Bool](true, URLEncode.check(\",%2C\", URLPartFragment))\n\n    // Misc characters, must be encoded.\n    h.assert_eq[Bool](true,\n      URLEncode.check(\"%23%3C%3E%5B%5D%7B%7D%7C%5E%25\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"<\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\">\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"|\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"^\", URLPartUser))\n\n    h.assert_eq[Bool](true, URLEncode.check(\"%23%3C\", URLPartPassword))\n    h.assert_eq[Bool](false, URLEncode.check(\"<\", URLPartPassword))\n    h.assert_eq[Bool](true, URLEncode.check(\"%23%3C\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"<\", URLPartHost))\n    h.assert_eq[Bool](true, URLEncode.check(\"%23%3C\", URLPartPath))\n    h.assert_eq[Bool](false, URLEncode.check(\"<\", URLPartPath))\n    h.assert_eq[Bool](true, URLEncode.check(\"%23%3C\", URLPartQuery))\n    h.assert_eq[Bool](false, URLEncode.check(\"<\", URLPartQuery))\n    h.assert_eq[Bool](true, URLEncode.check(\"%23%3C\", URLPartFragment))\n    h.assert_eq[Bool](false, URLEncode.check(\"<\", URLPartFragment))\n\n    // Delimiters, whether need to be encoded depends on URL part.\n    h.assert_eq[Bool](true, URLEncode.check(\"%3A%40%2F%3F\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\":\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"@\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"/\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"?\", URLPartUser))\n    h.assert_eq[Bool](true, URLEncode.check(\":%40%2F%3F\", URLPartPassword))\n    h.assert_eq[Bool](false, URLEncode.check(\"@\", URLPartPassword))\n    h.assert_eq[Bool](false, URLEncode.check(\"/\", URLPartPassword))\n    h.assert_eq[Bool](false, URLEncode.check(\"?\", URLPartPassword))\n    h.assert_eq[Bool](true, URLEncode.check(\"%3A%40%2F%3F\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\":\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"@\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"/\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"?\", URLPartHost))\n    h.assert_eq[Bool](true, URLEncode.check(\":@/%3F\", URLPartPath))\n    h.assert_eq[Bool](false, URLEncode.check(\"?\", URLPartPath))\n    h.assert_eq[Bool](true, URLEncode.check(\":@/?\", URLPartQuery))\n    h.assert_eq[Bool](true, URLEncode.check(\":@/?\", URLPartFragment))\n\nclass iso _CheckBad is UnitTest\n  fun name(): String => \"http/URLEncode.check_bad\"\n\n  fun apply(h: TestHelper) =>\n    h.assert_eq[Bool](false, URLEncode.check(\"%2G\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"%xx\", URLPartUser))\n    h.assert_eq[Bool](false, URLEncode.check(\"%2\", URLPartUser))\n\nclass iso _CheckScheme is UnitTest\n  fun name(): String => \"http/URLEncode.check_scheme\"\n\n  fun apply(h: TestHelper) =>\n    h.assert_eq[Bool](true, URLEncode.check_scheme(\"Aa4-+.\"))\n    h.assert_eq[Bool](false, URLEncode.check_scheme(\"_\"))\n    h.assert_eq[Bool](false, URLEncode.check_scheme(\":\"))\n    h.assert_eq[Bool](false, URLEncode.check_scheme(\"%41\"))\n\nclass iso _CheckIPv6 is UnitTest\n  fun name(): String => \"http/URLEncode.check_ipv6\"\n\n  fun apply(h: TestHelper) =>\n    // Allowed hex digits, '.' and ':' only, between '[' and ']'.\n    h.assert_eq[Bool](true, URLEncode.check(\"[1::A.B]\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"[G]\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"[/]\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"[%32]\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"[1]2\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"[1\", URLPartHost))\n    h.assert_eq[Bool](false, URLEncode.check(\"1]\", URLPartHost))\n\nclass iso _Decode is UnitTest\n  fun name(): String => \"http/URLEncode.decode\"\n\n  fun apply(h: TestHelper) ? =>\n    h.assert_eq[String](\"Aa4-._~Aa4-._~\",\n      URLEncode.decode(\"Aa4-._~%41%61%34%2D%2E%5F%7E\")?)\n\n    h.assert_eq[String](\"F_12x\", URLEncode.decode(\"F_1%32x\")?)\n\n    h.assert_eq[String](\"!$&'()* ,;=!$&'()*+,;=\",\n      URLEncode.decode(\"!$&'()*+,;=%21%24%26%27%28%29%2A%2B%2C%3B%3D\")?)\n\n    h.assert_eq[String](\"#<>[]{}|^ #<>[]{}|^ %\",\n      URLEncode.decode(\"#<>[]{}|^ %23%3C%3E%5B%5D%7B%7D%7C%5E%20%25\")?)\n\nclass iso _DecodeBad is UnitTest\n  fun name(): String => \"http/URLEncode.decode_bad\"\n\n  fun apply(h: TestHelper) =>\n    h.assert_error({() ? => URLEncode.decode(\"%2G\")? })\n    h.assert_error({() ? => URLEncode.decode(\"%xx\")? })\n    h.assert_error({() ? => URLEncode.decode(\"%2\")? })\n\nclass iso _BuildBasic is UnitTest\n  fun name(): String => \"http/URL.build_basic\"\n\n  fun apply(h: TestHelper) ? =>\n    _Test(h,\n      URL.build(\"https://user:password@host.name:12345/path?query#fragment\")?,\n      \"https\", \"user\", \"password\", \"host.name\", 12345, \"/path\", \"query\",\n      \"fragment\")\n\n    _Test(h,\n      URL.build(\"http://rosettacode.org/wiki/Category]Pony\")?,\n      \"http\", \"\", \"\", \"rosettacode.org\", 80, \"/wiki/Category%5DPony\", \"\", \"\")\n\n    _Test(h,\n      URL.build(\"https://en.wikipedia.org/wiki/Polymorphism_\" +\n        \"(computer_science)#Parametric_polymorphism\")?,\n      \"https\", \"\", \"\", \"en.wikipedia.org\", 443,\n      \"/wiki/Polymorphism_(computer_science)\", \"\",\n      \"Parametric_polymorphism\")\n\n    _Test(h, URL.build(\"http://user@host\")?,\n      \"http\", \"user\", \"\", \"host\", 80, \"/\", \"\", \"\")\n\nclass iso _BuildMissingParts is UnitTest\n  fun name(): String => \"http/URL.build_missing_parts\"\n\n  fun apply(h: TestHelper) ? =>\n    _Test(h, URL.build(\"https://user@host.name/path#fragment\")?,\n      \"https\", \"user\", \"\", \"host.name\", 443, \"/path\", \"\", \"fragment\")\n\n    _Test(h, URL.build(\"https://user@host.name#fragment\")?,\n      \"https\", \"user\", \"\", \"host.name\", 443, \"/\", \"\", \"fragment\")\n\n    _Test(h, URL.build(\"//host.name/path\")?,\n      \"\", \"\", \"\", \"host.name\", 0, \"/path\", \"\", \"\")\n\n    _Test(h, URL.build(\"/path\")?,\n      \"\", \"\", \"\", \"\", 0, \"/path\", \"\", \"\")\n\n    _Test(h, URL.build(\"?query\")?,\n      \"\", \"\", \"\", \"\", 0, \"/\", \"query\", \"\")\n\n    _Test(h, URL.build(\"#fragment\")?,\n      \"\", \"\", \"\", \"\", 0, \"/\", \"\", \"fragment\")\n\n    _Test(h, URL.build(\"https://host.name/path#frag?ment\")?,\n      \"https\", \"\", \"\", \"host.name\", 443, \"/path\", \"\", \"frag?ment\")\n\n    _Test(h, URL.build(\"https://user@host.name?quer/y#fragment\")?,\n      \"https\", \"user\", \"\", \"host.name\", 443, \"/\", \"quer/y\", \"fragment\")\n\nclass iso _BuildBad is UnitTest\n  fun name(): String => \"http/URL.build_bad\"\n\n  fun apply(h: TestHelper) =>\n    h.assert_error({() ? =>\n      URL.build(\"htt_ps://user@host.name/path#fragment\")?\n    })\n\n    h.assert_error({() ? =>\n      URL.build(\"https://[11::24_]/path\")?\n    })\n\n    h.assert_error({() ? =>\n      URL.build(\"https://[11::24/path\")?\n    })\n\n    h.assert_error({() ? =>\n      URL.build(\"https://host%2Gname/path\")?\n    })\n\n    h.assert_error({() ? =>\n      URL.build(\"https://hostname/path%\")?\n    })\n\nclass iso _BuildNoEncoding is UnitTest\n  fun name(): String => \"http/URL.build_no_encoding\"\n\n  fun apply(h: TestHelper) ? =>\n    _Test(h, URL.build(\"https://host.name/path%32path\", false)?,\n      \"https\", \"\", \"\", \"host.name\", 443, \"/path%2532path\", \"\", \"\")\n\nclass iso _Valid is UnitTest\n  fun name(): String => \"http/URL.valid\"\n\n  fun apply(h: TestHelper) ? =>\n    _Test(h,\n      URL.valid(\"https://user:password@host.name:12345/path?query#fragment\")?,\n      \"https\", \"user\", \"password\", \"host.name\", 12345, \"/path\", \"query\",\n      \"fragment\")\n\n    h.assert_error({() ? =>\n      URL.valid(\"http://rosettacode.org/wiki/Category[Pony]\")?\n    })\n\n    h.assert_error({() ? =>\n      URL.valid(\"https://en.wikipedia|org/wiki/Polymorphism_\" +\n        \"(computer_science)#Parametric_polymorphism\")?\n    })\n\n    _Test(h, URL.valid(\"http://user@host\")?,\n      \"http\", \"user\", \"\", \"host\", 80, \"/\", \"\", \"\")\n\nclass iso _ToStringFun is UnitTest\n  fun name(): String => \"http/URL.to_string\"\n\n  fun apply(h: TestHelper) ? =>\n    h.assert_eq[String](\n      \"https://user:password@host.name:12345/path?query#fragment\",\n      URL.build(\"https://user:password@host.name:12345/path?query#fragment\")?\n        .string())\n\n    h.assert_eq[String](\"http://rosettacode.org/wiki/Category%5DPony\",\n      URL.build(\"http://rosettacode.org/wiki/Category]Pony\")?.string())\n\n    h.assert_eq[String](\"http://user@host/\",\n      URL.build(\"http://user@host\")?.string())\n\n    // Default ports should be omitted.\n    h.assert_eq[String](\"http://host.name/path\",\n      URL.build(\"http://host.name:80/path\")?.string())\n\nprimitive _Test\n  fun apply(\n    h: TestHelper,\n    url: URL,\n    scheme: String,\n    user: String,\n    password: String,\n    host: String,\n    port: U16,\n    path: String,\n    query: String,\n    fragment: String)\n  =>\n    h.assert_eq[String](scheme, url.scheme)\n    h.assert_eq[String](user, url.user)\n    h.assert_eq[String](password, url.password)\n    h.assert_eq[String](host, url.host)\n    h.assert_eq[U16](port, url.port)\n    h.assert_eq[String](path, url.path)\n    h.assert_eq[String](query, url.query)\n    h.assert_eq[String](fragment, url.fragment)\n\n\nclass iso _PendingResponsesTest is Property1[Array[(RequestID, Array[U8] val)]]\n  let num_pending: USize = 100\n  fun name(): String => \"http/_pending_responses/property\"\n  fun gen(): Generator[Array[(RequestID, Array[U8] val)]] =>\n    // generate all ints between x and y in random order\n    // range\n    let range = Iter[USize](Range[USize](0, num_pending, 1))\n      .map[(RequestID, Array[U8] val)]({(s) =>\n        (\n          s,\n          recover val Array[U8].init(0, s) end\n        )\n      })\n      .collect(Array[(RequestID, Array[U8] val)](num_pending))\n    let shuffled_iter_gen = Generators.shuffled_iter[(RequestID, Array[U8] val)](range)\n    let shuffled_array_gen = shuffled_iter_gen.map[Array[(RequestID, Array[U8] val)]]({(iter) =>\n      Iter[(RequestID, Array[U8] val)](iter).collect(Array[(RequestID, Array[U8] val)](num_pending))\n    })\n    shuffled_array_gen\n\n\n  fun property(sample: Array[(RequestID, Array[U8] val)], h: PropertyHelper) =>\n    let pending_resp = _PendingResponses\n    for (request_id, response) in sample.values() do\n      pending_resp.add_pending(request_id, response)\n      if response.size() > 0 then\n        pending_resp.append_data(request_id, response)\n      end\n    end\n    h.log(pending_resp.debug())\n    // assert it has all the responses in correct order\n    for i in Range[USize](0, num_pending, 1) do\n      h.assert_isnt[((RequestID, ByteSeqIter val) | None)](None, pending_resp.pop(i))\n    end\n\n\n\n"}}}
"""